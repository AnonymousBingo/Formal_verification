(* Cryptographic Protocol Verification Script - Secrecy & Authentication Focused *)

(* --- Channels --- *)
free U_Si: channel. (* Public channel *)
free U_Sj: channel. (* Public channel *)
free Si_Sj: channel.
free Si_As: channel.
free Sj_As: channel.

(* --- Constants and Identifiers --- *)
free M : bitstring.            (* Public modulus *)
const Admin: bitstring.
const U_id_const: bitstring.  (* User U's identifier *)
const Si_id_const: bitstring. (* Server Si's identifier *)
const Sj_id_const: bitstring. (* Server Sj's identifier *)

(* --- Cryptographic Primitives --- *)
fun H(bitstring): bitstring. (* Hash function *)
fun pow(bitstring, bitstring): bitstring. (* Exponentiation *)
fun mod(bitstring, bitstring): bitstring. (* Modulo operation *)

type skey. (* Type for secret keys *)
type pkey. (* Type for public keys *)
fun pkey_func(skey): pkey. (* Public key generation *)
fun sign(bitstring, skey): bitstring. (* Signing *)
reduc forall m:bitstring, sk:skey; checksign(sign(m,sk), pkey_func(sk)) = m. 
(* Signature verification *)

(* Key definitions *)
const skU_actual: skey [private].
const skSi_actual: skey [private].
const skSj_actual: skey [private].

fun encrypt(bitstring, pkey): bitstring. (* Asymmetric encryption *)
reduc forall m: bitstring, sk: skey; decrypt(encrypt(m, pkey_func(sk)), sk) = m. (* Asymmetric decryption *)

(* --- Event Declarations --- *)
(* Event for User U starting the process with Server Si *)
event U_starts_Si_process(bitstring, bitstring). (* UserID, ServerSiID *)

(* Event for Server Si authenticating User U *)
event U_authenticated_by_Si(bitstring, bitstring). (* UserID, ServerSiID *)

(* Event for User U starting the process with Server Sj (in the context of Si) *)
(* Parameters: UserID, ServerSiID_context, ServerSjID_target *)
event U_starts_Sj_process(bitstring, bitstring, bitstring).

(* Event for Server Sj authenticating User U (in the context of Si) *)
(* Parameters: UserID, ServerSiID_context, ServerSjID_target *)
event U_authenticated_by_Sj(bitstring, bitstring, bitstring).

(* --- Queries --- *)

(* Secrecy Queries *)
query attacker(new state_u).       (* Can attacker learn the user's session state 'state_u'? *)
query attacker(new state_si).      (* Can attacker learn server Si's session state 'state_si'? *)
query attacker(new state_sj).
query attacker(new C_challenge).   (* Can attacker learn the challenge C generated by Si? *)

(* --- Correspondence Queries --- *)

(* Query 1: Server Si authenticates User U only if U started the process with Si. *)
(* This checks that if Si believes U (idUser) is authenticated with Si (idServerSi), *)
(* then U must have initiated an interaction intended for that specific Si. *)
query idUser_Si:bitstring, idServer_Si:bitstring;
    event(U_authenticated_by_Si(idUser_Si, idServer_Si)) ==> event(U_starts_Si_process(idUser_Si, idServer_Si)).

(* Query 2: Server Sj authenticates User U (in context of Si) only if U started the process with Sj (for that Si context). *)
(* This checks that if Sj (idServer_Sj) believes U (idUser_Sj) is authenticated *)
(* (in the context of a specific Si, idServerSi_ctx), then U must have initiated an interaction *)
(* intended for that Sj, specifying that same Si as context. *)
query idUser_Sj:bitstring, idServerSi_ctx:bitstring, idServer_Sj:bitstring;
    event(U_authenticated_by_Sj(idUser_Sj, idServerSi_ctx, idServer_Sj)) ==> event(U_starts_Sj_process(idUser_Sj, idServerSi_ctx, idServer_Sj)).


(* --- Injectivity Queries --- *)

(* Injectivity Query 1: For every instance of Si authenticating U, there's a unique instance of U starting the process with Si. *)
(* This ensures a one-to-one mapping from Si's authentication of U back to U's initiation. *)
query idUser_Si_inj:bitstring, idServer_Si_inj:bitstring;
    inj-event(U_authenticated_by_Si(idUser_Si_inj, idServer_Si_inj)) ==> inj-event(U_starts_Si_process(idUser_Si_inj, idServer_Si_inj)).

(* Injectivity Query 2: For every instance of Sj authenticating U (in context of Si), there's a unique instance of U starting the process with Sj (for that Si context). *)
(* This ensures a one-to-one mapping from Sj's authentication of U back to U's initiation for that specific context. *)
query idUser_Sj_inj:bitstring, idServerSi_ctx_inj:bitstring, idServer_Sj_inj:bitstring;
    inj-event(U_authenticated_by_Sj(idUser_Sj_inj, idServerSi_ctx_inj, idServer_Sj_inj)) ==> inj-event(U_starts_Sj_process(idUser_Sj_inj, idServerSi_ctx_inj, idServer_Sj_inj)).


(* --- Process for User U --- *)
(* state_u is the user's secret for this session. pkSi_for_U is Si's public key. *)
let processU(skU: skey, state_u: bitstring, pkSi_for_U: pkey, idU: bitstring, idSi_u: bitstring, idSj_target: bitstring) =
    let pkU = pkey_func(skU) in
    let Hash_state_u = H(state_u) in

    (* U intends to start interaction with Si *)
    event U_starts_Si_process(idU, idSi_u);

    (* U sends id to Si *)
    out(U_Si, (U_id_const));
    in(U_Si, (enc_challenge: bitstring));
    let C = decrypt(enc_challenge, skU) in

    let ARGc = mod(pow(C, state_u), M) in
    let Hash_ARGc = H(ARGc) in
    let sign_ARGc = sign(Hash_ARGc, skU) in
    
    (* U sends its response to Si *)
    out(U_Si, (sign_ARGc, Hash_state_u));
    
    (* U intends to start interaction with Sj, in context of Si *)
    event U_starts_Sj_process(idU, idSi_u, idSj_target);

    (* U sends a request to Sj *)
    out(U_Sj, (idU, idSi_u, idSj_target, Hash_state_u)).

(* --- Process for Server S_i --- *)
(* state_si is Si's secret for this session. pkSj_pre_trusted is Sj's public key. *)
let processSi(skSi: skey, state_si: bitstring, pkSj_pre_trusted: pkey, pkU_si: pkey, idU_si: bitstring, idSi: bitstring) =
    let pkSi = pkey_func(skSi) in

    in(U_Si, (U_id_rcvd: bitstring));
    (* Si generates a fresh challenge C *)
    new C_challenge: bitstring;
    out(U_Si, (encrypt(C_challenge,pkU_si)));


    in(U_Si, (sign_ARGc_rcvd: bitstring, Hash_state_u_rcvd: bitstring));
    out(Si_As, (idU_si, idSi, Hash_state_u_rcvd));
    in(Si_As, (enc_state_u: bitstring));

    let state_u_As = decrypt(enc_state_u, skSi) in
    let Hash_state_u_As = H(state_u_As) in

    if Hash_state_u_rcvd = Hash_state_u_As then    
        let ARGc_Si = mod(pow(C_challenge, state_u_As), M) in
        let Hash_Si_ARGc = H(ARGc_Si) in
        let ARGc_rcvd = checksign(sign_ARGc_rcvd, pkU_si) in
        if ARGc_rcvd = Hash_Si_ARGc then
            (* === U authenticated to Si === *)
            event U_authenticated_by_Si(idU_si, idSi); 

            in(Si_Sj, (idU_Sj: bitstring, Hash_state_u_Sj: bitstring, idSi_Sj: bitstring));
            if Hash_state_u_Sj = Hash_state_u_As then
                let ARG2c = mod(pow(ARGc_Si, state_si), M) in
                let Hash_ARG2c = H(ARG2c) in
                let Sign1_ARG2c = sign(Hash_ARG2c, skSi) in
                let Sign2_ARGc_Si = sign(sign_ARGc_rcvd, skSi) in

                let C_enc = encrypt(C_challenge, pkSj_pre_trusted) in 

                out(Si_Sj, (C_enc, Sign2_ARGc_Si, Sign1_ARG2c, idSi, pkSi)).



(* --- Process for Server S_j --- *)
let processSj(skSj: skey, pkU_pre_trusted_by_Sj: pkey, pkSi_pre_trusted: pkey, idSj: bitstring) =
    (* pkSj is Sj's public key, not explicitly used for sending in this version but defined for completeness *)
    let pkSj = pkey_func(skSj) in
    
    in(U_Sj, (idU_rcvd: bitstring, idSi_rcvd_u: bitstring, Hash_stateu_rcvd: bitstring));
    out(Si_Sj, (idU_rcvd, Hash_stateu_rcvd, idSi_rcvd_u));

    in(Si_Sj, (C_enc_rcvd: bitstring, Sign2_ARGc_Si_rcvd: bitstring, Sign1_ARG2c_rcvd: bitstring, idSi_rcvd: bitstring, pkSi_rcvd: bitstring));

    out(Sj_As, (idU_rcvd, idSi_rcvd, idSj));
    in(Sj_As, (enc_state_u: bitstring, enc_state_si: bitstring));

    let state_u = decrypt(enc_state_u, skSj) in
    let state_si = decrypt(enc_state_si, skSj) in

    if H(state_u) = Hash_stateu_rcvd then 

        let Sign1_ARGc_content_Si = checksign( Sign2_ARGc_Si_rcvd, pkSi_pre_trusted) in
        let Sign1_ARGc_content = checksign(Sign1_ARGc_content_Si, pkU_pre_trusted_by_Sj) in
        let Sign2_ARG2c_content = checksign( Sign2_ARGc_Si_rcvd, pkSi_pre_trusted) in

        let C_challenge = decrypt(C_enc_rcvd, skSj) in
        let Hash_c = H(C_challenge) in
        let re_ARGc = mod(pow(C_challenge, state_u), M) in
        let Hash_re_ARGc = H(re_ARGc) in 
        let re_ARG2c = mod(pow(re_ARGc, state_si), M) in
        let Hash_re_ARG2c = H(re_ARG2c) in 

        if Hash_re_ARG2c = Sign2_ARG2c_content then 
            if Hash_c = Sign1_ARGc_content then 
                event U_authenticated_by_Sj(idU_rcvd, idSi_rcvd, idSj).





let processAS(state_u: bitstring, state_si: bitstring, state_sj: bitstring, pkSi: pkey, pkSj: pkey) = 
    in(Si_As, (idU_rcvd: bitstring , idSi_rcvd: bitstring, Hash_state_u_rcvd: bitstring)); 
    if Hash_state_u_rcvd = H(state_u) then 
        out(Si_As, (encrypt(state_u, pkSi)));

    in(Sj_As, (idU_rcvd_sj: bitstring, idSi_rcvd_sj: bitstring, idSj_rcvd: bitstring)); 
    out(Sj_As, (encrypt(state_u, pkSj), encrypt(state_si, pkSj))).



(* --- Main Process --- *)
process     
    let pkU_actual = pkey_func(skU_actual) in
    let pkSi_actual = pkey_func(skSi_actual) in
    let pkSj_actual = pkey_func(skSj_actual) in
    new state_u: bitstring;    (* User's secret state for this session *)
    new state_si: bitstring;   (* Server Si's secret state for this session *)
    new state_sj: bitstring;

    (
        (* User U process instance *)
        (!processU(skU_actual, state_u, pkSi_actual, U_id_const, Si_id_const, Sj_id_const)) |
        (* Server S_i process instance *)
        (!processSi(skSi_actual, state_si, pkSj_actual, pkU_actual, U_id_const, Si_id_const)) |
        (* Server S_j process instance *)
        (!processSj(skSj_actual, pkU_actual, pkSi_actual, Sj_id_const)) |
        (* Server As Process instance *)
        (! processAS(state_u, state_si, state_sj, pkSi_actual, pkSj_actual))
    )
